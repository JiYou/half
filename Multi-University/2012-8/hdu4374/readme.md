#hdu4374 One hundred layer
>有 N (~100)层楼,每层有 M(~10000) 个房间，每个房间都有一个分数 score(-500~500) ;<br>
>我们把每一层的房间从左往右1,2,……,m标号;<br>
>玩家从第一层的第 X (<=M)号房间进入这栋房子，他可以往左最多走 T 步，或往右最多走 T 步，<br>
>注意只能往一个方向。<br>
>在他走过第 i 层的第 j 号房间时，他可以选择是否进入的第 i+1 层的第 j 号房间,同样进入后最多只能走 T 步;<br>
>每走过一个房间玩家就能得到该房间的分数,求最大分数和；<br>

* 乍一看就会觉得是dp ,并且状态也很容易想到 dp(i , j):表示从第 i 层的 j 号房间离开时的最大分数。<br>
* 设 a(i,j):表示第 i 层前 j 个房间的分数和；<br>
* 也很好转移：dp(i , j) 从 i-1 层左边过来： max (dp(i-1 , k) + a(i , j)-a(i , k-1) ;<br>
* 或者从右边转移过来：max (dp(i-1 , k) + a(i , k)-a(i , j-1);<br>
* 显然最朴素的转移的复杂度为O(n \* m \* m) , 妥妥的超时；<br>
* 然后让我们重新整理一下转移式，以左边为例：<br>
* dp(i , j) = max( (dp(i-1 , k) + a(i , k-1)) ) + a(i , j);<br>
* 明显 dp(i-1 , k) + a(i , k-1) 与 dp(i , j) 独立 ;<br>
* 及我们只要从 i-1 层的[j-T , j-1]的区间里选一个位置使得　dp(i-1 , k) + a(i , k-1)　最大即可;<br>
* 要实现这个的方法有很多，通称叫做 RMQ 算法，常用的有 ST算法 ,线段树 ,动态树,还有单调队列;<br>
* 其中单调队列是书写复杂度最低一种；<br>