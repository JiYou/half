#zoj3917 Colors of Cards
>题意：给定n张卡片，形如WWWBWWWWBW ；和k , 表示你可以任意翻一段长度为k的区间，使得在这个区间中B->W,W->B。其中如果当前这个区间包含边界，那么该区间的长度可以小于k。<br>

一开始觉得可以贪心，但后来找出了反例：WWBWWWWWWBWW ;<br>
后来听铭神说是dp:<br>
* 要让n张卡片都相同，那我们只要保证让所有相邻两项相等即可（废话）；<br>
* 我们设操作为op[ ]：op[i] = 1表示让[i,i+k-1]这个区间反转；(这里i可以小于0，比如说k=3,WWB,我要只想让a[0]反转，那么我可以执行op[-2]这个操作，你可以认为在前面添加k-1个无关项)<br>
* 然后我们发现如果要让相邻两项相同要保证以下两个条件：<br>
* 如果a[i]!=a[i-1] , 那么op[i] = !op[i-k] ;<br>
* 如果a[i]==a[i-1] , 那么op[i] = op[i-k] ;<br>
* 
* 然后我们就可以处理了：<br>
* 我们把n张卡片按照mod k分成k个类，每个类除了会影响a[0]外，都相互独立。<br>
* 最后我们只要讨论op[-k+1],op[-k+2],op[-k+3],……,op[0]分别是什么状态即可，这个过程和操作的先后顺序无关，所以dp即可。<br>